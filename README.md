# TPSpring2024_WEB_FS
## Module 1
### Task1
Если в числе содержится только один бит со значением 1, записать в выходной
поток OK. Иначе записать FAIL

### Task2
Дан отсортированный массив целых чисел A[0..n-1] и массив целых чисел
B[0..m-1]. Для каждого элемента массива B[i] найдите минимальный индекс k
минимального элемента массива A, равного или превосходящего B[i]: A[k] >= B[i].
Если такого элемента нет, выведите n. n, m ≤ 10000. Требования:  Время работы
поиска k для каждого элемента B[i]: O(log(k)). Внимание! В этой задаче для
каждого B[i] сначала нужно определить диапазон для бинарного поиска размером
порядка k с помощью экспоненциального поиска, а потом уже в нем делать бинарный
поиск. Формат входных данных. В первой строчке записаны числа n и m. Во второй и
третьей массивы A и B соответственно.

### Task3
Реализовать очередь с динамическим зацикленным буфером (на основе
динамического массива). Требования: Очередь должна быть реализована в виде
класса.

### Task4
В операционной системе Technux есть планировщик процессов.
Каждый процесс характеризуется: приоритетом P
временем, которое он уже отработал t
временем, которое необходимо для завершения работы процесса T
Планировщик процессов выбирает процесс с минимальным значением P * (t + 1),
выполняет его время P и кладет обратно в очередь процессов. Если выполняется
условие t >= T, то процесс считается завершенным и удаляется из очереди.
Требуется посчитать кол-во переключений процессора.
Формат входных данных:  Сначала вводится кол-во процессов. После этого процессы
в формате P T Формат выходных данных: Кол-во переключений процессора.

### Task5
На числовой прямой окрасили N отрезков. Известны координаты левого и правого
концов каждого отрезка (Li и Ri). Найти сумму длин частей числовой прямой,
окрашенных ровно в один слой

### Task6
Реализуйте стратегию выбора опорного элемента “случайный элемент”. Функцию
Partition реализуйте методом прохода двумя итераторами от конца массива к
началу.

### Task7
Дан массив строк. Количество строк не больше 105. Отсортировать массив методом
поразрядной сортировки MSD по символам. Размер алфавита - 256 символов.
Последний символ строки = ‘\0’.

## Module 2
### Task 1
Реализуйте структуру данных типа “множество строк” на основе динамической хеш-таблицы с открытой адресацией. Хранимые строки непустые и состоят из строчных латинских букв.
Хеш-функция строки должна быть реализована с помощью вычисления значения многочлена методом Горнера.
Начальный размер таблицы должен быть равным 8-ми. Перехеширование выполняйте при добавлении элементов в случае, когда коэффициент заполнения таблицы достигает 3/4.
Структура данных должна поддерживать операции добавления строки в множество, удаления строки из множества и проверки принадлежности данной строки множеству.

### Task 2
Дано число N < 106 и последовательность целых чисел из [-231..231] длиной N.
Требуется построить бинарное дерево, заданное наивным порядком вставки.
Т.е., при добавлении очередного числа K в дерево с корнем root, если root→Key ≤ K, то узел K добавляется в правое поддерево root; иначе в левое поддерево root.

### Task 3
Постройте B-дерево минимального порядка t и выведите его по слоям.
В качестве ключа используются числа, лежащие в диапазоне 0..232 -1

### Task 4
В одной военной части решили построить в одну шеренгу по росту. Т.к. часть была далеко не образцовая, то солдаты часто приходили не вовремя, а то их и вовсе приходилось выгонять из шеренги за плохо начищенные сапоги. Однако солдаты в процессе прихода и ухода должны были всегда быть выстроены по росту – сначала самые высокие, а в конце – самые низкие. За расстановку солдат отвечал прапорщик, который заметил интересную особенность – все солдаты в части разного роста. Ваша задача состоит в том, чтобы помочь прапорщику правильно расставлять солдат, а именно для каждого приходящего солдата указывать, перед каким солдатом в строе он должен становится. 

### Task 5
В архиве сохраняйте дерево Хаффмана и код Хаффмана от исходных данных.
Дерево Хаффмана требуется хранить эффективно - не более 10 бит на каждый 8-битный символ.
В контест необходимо отправить .cpp файл содержащий функции Encode, Decode, а также включающий файл Huffman.h. Тестирующая программа выводит размер сжатого файла в процентах от исходного.
